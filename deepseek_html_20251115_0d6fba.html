<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Christmas Tree</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505; /* 深邃黑背景 */
            font-family: 'Helvetica Neue', Arial, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* 摄像头预览（用于调试，实际可隐藏或做小窗） */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 2;
            width: 160px;
            height: 120px;
            border: 1px solid #333;
            border-radius: 8px;
            overflow: hidden;
            opacity: 0.7;
            transform: scaleX(-1); /* 镜像翻转 */
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* UI 控件 */
        #ui-layer {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 3;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn {
            background: rgba(255, 215, 0, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 20px;
            font-size: 14px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
        }

        .btn:hover {
            background: rgba(255, 215, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.5);
        }

        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.8);
            z-index: 3;
            font-size: 14px;
            pointer-events: none;
        }
        
        #status span {
            color: #FFD700;
            font-weight: bold;
        }

        /* 隐藏的文件输入 */
        #file-input {
            display: none;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #FFD700;
            font-size: 24px;
            z-index: 10;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="loading">Loading Magic...<br><span style="font-size:14px; color:#aaa">Please allow camera access</span></div>
    
    <div id="status">Current State: <span id="state-text">INITIALIZING</span></div>

    <div id="video-container">
        <video id="input-video" playsinline></video>
    </div>

    <div id="ui-layer">
        <button class="btn" onclick="document.getElementById('file-input').click()">Upload Photos</button>
        <input type="file" id="file-input" multiple accept="image/*">
    </div>

    <div id="canvas-container"></div>

    <!-- Import Maps for Three.js and MediaPipe -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- 全局配置与状态 ---
        const CONFIG = {
            particleCount: 1500,
            photoCount: 0, // 动态根据上传增加
            colors: {
                green: 0x2F5A2F, // 哑光绿
                gold: 0xFFD700,  // 金属金
                red: 0x8B0000,   // 圣诞红
                white: 0xEEEEEE
            },
            treeHeight: 40,
            treeRadius: 15
        };

        const STATE = {
            CONVERGED: 'CONVERGED', // 圣诞树合拢
            SCATTERED: 'SCATTERED', // 散开
            ZOOMED: 'ZOOMED'        // 照片放大
        };

        let currentState = STATE.CONVERGED;
        let targetState = STATE.CONVERGED;
        let activePhotoIndex = -1; // 当前聚焦的照片索引

        // Three.js 核心变量
        let scene, camera, renderer, composer, controls;
        let clock = new THREE.Clock();
        
        // 粒子系统
        let particles = []; // 存储所有粒子逻辑对象 { mesh, index, treePos, scatterPos, currentPos }
        let instancedMeshes = {}; // 分类存储 InstancedMesh
        let photoMeshes = []; // 单独存储照片 Mesh

        // MediaPipe 变量
        let gestureRecognizer;
        let video;
        let lastVideoTime = -1;
        let handResults = undefined;

        // 交互平滑
        let handRotation = { x: 0, y: 0 };
        let targetCameraPos = new THREE.Vector3();

        // --- 初始化入口 ---
        async function init() {
            initThree();
            createParticles();
            setupInteractions();
            await initMediaPipe();
            document.getElementById('loading').style.display = 'none';
            animate();
        }

        // --- 1. Three.js 场景设置 ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // 相机
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 60);
            targetCameraPos.copy(camera.position);

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // 后处理 (Bloom 辉光)
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // 增强辉光
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 灯光
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 2);
            dirLight.position.set(10, 20, 10);
            scene.add(dirLight);

            // 点光源增加节日气氛
            const pointLight1 = new THREE.PointLight(CONFIG.colors.gold, 2, 100);
            pointLight1.position.set(0, 20, 20);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(CONFIG.colors.red, 2, 100);
            pointLight2.position.set(0, 5, -20);
            scene.add(pointLight2);

            // 控制器 (用于调试，手势控制时会覆盖)
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
        }

        // --- 2. 粒子与内容生成 ---
        function createParticles() {
            // 几何体与材质
            const geoSphere = new THREE.SphereGeometry(0.3, 16, 16);
            const geoBox = new THREE.BoxGeometry(0.4, 0.4, 0.4);
            const geoCylinder = new THREE.CylinderGeometry(0.1, 0.1, 1, 8); // 糖果棍

            const matGreen = new THREE.MeshStandardMaterial({ color: CONFIG.colors.green, roughness: 0.8 });
            const matGold = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, metalness: 0.9, roughness: 0.1 });
            const matRed = new THREE.MeshStandardMaterial({ color: CONFIG.colors.red, metalness: 0.4, roughness: 0.3 });

            // 创建 InstancedMeshes
            const meshCounts = { green: 1000, gold: 300, red: 200 };
            
            instancedMeshes.green = new THREE.InstancedMesh(geoSphere, matGreen, meshCounts.green);
            instancedMeshes.gold = new THREE.InstancedMesh(geoSphere, matGold, meshCounts.gold);
            instancedMeshes.red = new THREE.InstancedMesh(geoBox, matRed, meshCounts.red);

            scene.add(instancedMeshes.green);
            scene.add(instancedMeshes.gold);
            scene.add(instancedMeshes.red);

            // 初始化位置数据
            const dummy = new THREE.Object3D();

            const initGroup = (mesh, count, type) => {
                for (let i = 0; i < count; i++) {
                    // 1. 树形态位置 (圆锥螺旋)
                    const angle = Math.random() * Math.PI * 2 * 10; // 螺旋圈数
                    const heightPercent = Math.random();
                    const y = heightPercent * CONFIG.treeHeight - CONFIG.treeHeight / 2;
                    const r = (1 - heightPercent) * CONFIG.treeRadius;
                    
                    // 增加一些随机抖动，让树看起来自然蓬松
                    const jitter = 1.5;
                    const treePos = new THREE.Vector3(
                        Math.cos(angle) * r + (Math.random()-0.5)*jitter,
                        y,
                        Math.sin(angle) * r + (Math.random()-0.5)*jitter
                    );

                    // 2. 散开形态位置 (球体随机分布)
                    const scatterPos = new THREE.Vector3(
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 80,
                        (Math.random() - 0.5) * 80
                    );

                    // 初始设为树形态
                    dummy.position.copy(treePos);
                    dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                    dummy.scale.setScalar(type === 'gold' ? Math.random()*1.5 + 0.5 : Math.random() + 0.5);
                    dummy.updateMatrix();
                    mesh.setMatrixAt(i, dummy.matrix);

                    // 存储逻辑数据
                    particles.push({
                        mesh: mesh,
                        index: i,
                        treePos: treePos,
                        scatterPos: scatterPos,
                        currentPos: treePos.clone(),
                        rotationSpeed: { x: Math.random()*0.02, y: Math.random()*0.02 }
                    });
                }
                mesh.instanceMatrix.needsUpdate = true;
            };

            initGroup(instancedMeshes.green, meshCounts.green, 'green');
            initGroup(instancedMeshes.gold, meshCounts.gold, 'gold');
            initGroup(instancedMeshes.red, meshCounts.red, 'red');
        }

        // 添加照片
        function addPhoto(texture) {
            const aspect = texture.image.width / texture.image.height;
            const geo = new THREE.PlaneGeometry(3 * aspect, 3);
            const mat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.9
            });
            const mesh = new THREE.Mesh(geo, mat);

            // 树位置 (放在树表面外侧)
            const angle = Math.random() * Math.PI * 2;
            const heightPercent = Math.random() * 0.8 + 0.1; // 避免太高或太低
            const y = heightPercent * CONFIG.treeHeight - CONFIG.treeHeight / 2;
            const r = (1 - heightPercent) * CONFIG.treeRadius + 2; // 稍微浮在树表面
            const treePos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
            
            // 散开位置
            const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 40 + 20 // 稍微靠前
            );

            mesh.position.copy(treePos);
            mesh.lookAt(0, y, 0); // 面向中心
            scene.add(mesh);

            photoMeshes.push({
                mesh: mesh,
                treePos: treePos,
                treeRot: mesh.quaternion.clone(),
                scatterPos: scatterPos,
                scatterRot: new THREE.Quaternion().setFromEuler(new THREE.Euler(Math.random(), Math.random(), 0)),
                currentPos: treePos.clone()
            });

            CONFIG.photoCount++;
        }

        function setupInteractions() {
            // 文件上传处理
            const fileInput = document.getElementById('file-input');
            fileInput.addEventListener('change', (e) => {
                const files = e.target.files;
                if (!files.length) return;

                const loader = new THREE.TextureLoader();
                for (let i = 0; i < files.length; i++) {
                    const url = URL.createObjectURL(files[i]);
                    loader.load(url, (texture) => {
                        addPhoto(texture);
                    });
                }
            });

            // 窗口调整
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // --- 3. MediaPipe 手势识别 ---
        async function initMediaPipe() {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
            );
            gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 1
            });

            // 设置视频流
            video = document.getElementById('input-video');
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            video.srcObject = stream;
            video.play();
        }

        function detectGestures() {
            if (!gestureRecognizer || !video.videoWidth) return;

            let nowInMs = Date.now();
            if (video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                handResults = gestureRecognizer.recognizeForVideo(video, nowInMs);
            }

            if (handResults && handResults.gestures.length > 0) {
                const gesture = handResults.gestures[0][0]; // 取第一个手的第一个手势
                const categoryName = gesture.categoryName;
                const score = gesture.score;
                
                // 获取手部中心点用于控制旋转
                const landmarks = handResults.landmarks[0];
                // 9号点是中指根部，大致为手掌中心
                const handX = landmarks[9].x; 
                const handY = landmarks[9].y;

                updateStateFromGesture(categoryName, score, handX, handY);
            }
        }

        function updateStateFromGesture(gesture, score, handX, handY) {
            const statusEl = document.getElementById('state-text');
            
            // 状态机逻辑
            // Gestures: "Closed_Fist", "Open_Palm", "Pointing_Up", "Thumb_Down", "Thumb_Up", "Victory", "ILoveYou"
            
            // 1. 握拳 -> 合拢态
            if (gesture === "Closed_Fist") {
                targetState = STATE.CONVERGED;
                statusEl.innerText = "CONVERGED (Tree Mode)";
            }
            // 2. 张开五指 -> 散开态
            else if (gesture === "Open_Palm") {
                targetState = STATE.SCATTERED;
                statusEl.innerText = "SCATTERED (Magic Mode)";
                
                // 手势控制旋转 (仅在散开态)
                // handX 0-1 (Left-Right in video). Video is mirrored in CSS but landmarks are relative to source.
                // Center is 0.5.
                handRotation.x = (handX - 0.5) * 2; // -1 to 1
                handRotation.y = (handY - 0.5) * 2;
            }
            // 3. 捏合/抓取 (用 Victory 或 Thumb_Up 近似模拟抓取，或者简单的 Pinch 检测)
            // GestureRecognizer 自带没有 Grab，这里用 "Victory" (V字手) 模拟进入照片模式，或者通过 landmarks 计算捏合距离
            // 为简化，设定：如果大拇指指尖(4)和食指指尖(8)距离很近
            const landmarks = handResults.landmarks[0];
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));

            if (distance < 0.05 && targetState === STATE.SCATTERED && photoMeshes.length > 0) {
                targetState = STATE.ZOOMED;
                statusEl.innerText = "ZOOMED (Photo Mode)";
                if (activePhotoIndex === -1) {
                    activePhotoIndex = Math.floor(Math.random() * photoMeshes.length);
                }
            } else if (distance > 0.1 && targetState === STATE.ZOOMED) {
                // 松开捏合，不一定马上退出，靠手掌张开退出
                activePhotoIndex = -1;
            }

            currentState = targetState;
        }

        // --- 4. 动画主循环 ---
        function animate() {
            requestAnimationFrame(animate);
            detectGestures();

            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // 1. 更新粒子位置
            const dummy = new THREE.Object3D();
            
            // 缓动系数
            const lerpSpeed = 0.05;

            particles.forEach(p => {
                let targetPos = (currentState === STATE.CONVERGED) ? p.treePos : p.scatterPos;

                // 插值移动
                p.currentPos.lerp(targetPos, lerpSpeed);

                // 旋转
                dummy.position.copy(p.currentPos);
                
                // 如果是树形态，整体旋转
                if (currentState === STATE.CONVERGED) {
                    const rotSpeed = 0.2;
                    const angle = time * rotSpeed;
                    const x = p.currentPos.x * Math.cos(angle) - p.currentPos.z * Math.sin(angle);
                    const z = p.currentPos.x * Math.sin(angle) + p.currentPos.z * Math.cos(angle);
                    dummy.position.set(x, p.currentPos.y, z);
                } else {
                    // 散开态自转
                    dummy.rotation.x += p.rotationSpeed.x;
                    dummy.rotation.y += p.rotationSpeed.y;
                }
                
                dummy.updateMatrix();
                p.mesh.setMatrixAt(p.index, dummy.matrix);
            });

            // 更新 InstancedMesh
            instancedMeshes.green.instanceMatrix.needsUpdate = true;
            instancedMeshes.gold.instanceMatrix.needsUpdate = true;
            instancedMeshes.red.instanceMatrix.needsUpdate = true;

            // 2. 更新照片位置
            photoMeshes.forEach((p, idx) => {
                let targetPos = (currentState === STATE.CONVERGED) ? p.treePos : p.scatterPos;
                let targetRot = (currentState === STATE.CONVERGED) ? p.treeRot : p.scatterRot;

                // 特殊处理 Zoom 态
                if (currentState === STATE.ZOOMED && idx === activePhotoIndex) {
                   // 聚焦照片保持不动或稍微前移
                   // 相机会动，照片不用剧烈动
                }

                p.mesh.position.lerp(targetPos, lerpSpeed);
                
                if (currentState === STATE.CONVERGED) {
                     // 树旋转逻辑同上
                    const rotSpeed = 0.2;
                    const angle = time * rotSpeed;
                    const x = targetPos.x * Math.cos(angle) - targetPos.z * Math.sin(angle);
                    const z = targetPos.x * Math.sin(angle) + targetPos.z * Math.cos(angle);
                    p.mesh.position.set(x, targetPos.y, z);
                    p.mesh.lookAt(0, targetPos.y, 0); // 始终朝向树中心（背对）? 不，照片应该朝外
                    p.mesh.lookAt(x * 2, targetPos.y, z * 2); 
                } else {
                     p.mesh.quaternion.slerp(targetRot, lerpSpeed);
                     p.mesh.lookAt(camera.position); // 散开时朝向相机
                }
            });

            // 3. 相机控制
            if (currentState === STATE.ZOOMED && activePhotoIndex !== -1) {
                // 推进到特定照片
                const targetPhoto = photoMeshes[activePhotoIndex].mesh;
                // 计算照片前方的位置
                const offset = new THREE.Vector3(0, 0, 5);
                offset.applyQuaternion(targetPhoto.quaternion);
                const camTarget = targetPhoto.position.clone().add(offset);
                
                camera.position.lerp(camTarget, 0.05);
                controls.target.lerp(targetPhoto.position, 0.05);
                controls.autoRotate = false;

            } else if (currentState === STATE.SCATTERED) {
                // 根据手势旋转相机
                // 基础位置
                const radius = 60;
                // 将手势坐标 (-1 to 1) 映射到角度
                const theta = handRotation.x * Math.PI; // 水平范围
                const phi = (1 - (handRotation.y + 1) / 2) * Math.PI / 2 + 0.1; // 垂直范围

                // 简单的 Orbit 逻辑
                const x = radius * Math.sin(theta);
                const z = radius * Math.cos(theta);
                
                // 平滑过渡
                camera.position.lerp(new THREE.Vector3(x, camera.position.y, z), 0.05);
                camera.lookAt(0, 0, 0);
                controls.target.set(0, 0, 0);
                controls.autoRotate = false;

            } else {
                // Converged State
                controls.autoRotate = true; // 自动旋转展示
                // 恢复默认视角高度
                camera.position.y = THREE.MathUtils.lerp(camera.position.y, 10, 0.02);
                const dist = camera.position.distanceTo(new THREE.Vector3(0,0,0));
                if(Math.abs(dist - 60) > 1) {
                    camera.translateZ((60 - dist) * 0.05);
                }
            }

            controls.update();
            composer.render();
        }

        // 启动应用
        init();
    </script>
</body>
</html>
