<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ„ Gesture Xmas Tree | AI Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050a05; font-family: 'Segoe UI', sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* UI Overlay */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;
            pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-text {
            color: #d4af37; /* Metallic Gold */
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            text-transform: uppercase; letter-spacing: 2px;
        }

        #status { font-size: 1.2rem; font-weight: bold; transition: color 0.3s; }
        .status-active { color: #ff3333; text-shadow: 0 0 15px red; }

        #controls {
            pointer-events: auto;
            background: rgba(0, 20, 10, 0.6);
            backdrop-filter: blur(10px);
            padding: 20px; border-radius: 12px;
            border: 1px solid #d4af37;
            max-width: 300px;
        }

        button, input::file-selector-button {
            background: linear-gradient(45deg, #d4af37, #b8860b);
            border: none; padding: 10px 20px; color: #000; font-weight: bold;
            cursor: pointer; border-radius: 4px; margin-top: 10px; width: 100%;
            transition: transform 0.2s;
        }
        button:hover { transform: scale(1.05); }

        /* Webcam feedback (small) */
        #webcam-preview {
            position: absolute; bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border: 2px solid #d4af37; border-radius: 8px;
            transform: scaleX(-1); /* Mirror */
            opacity: 0.7;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #d4af37; font-size: 2rem; z-index: 100;
        }
    </style>
</head>
<body>

    <!-- Loading Screen -->
    <div id="loading">ğŸ… åˆå§‹åŒ–é­”æ³•å¼•æ“...</div>

    <!-- 3D Canvas -->
    <div id="canvas-container"></div>

    <!-- Webcam Video (Hidden for processing, shown in canvas or small box) -->
    <video id="input-video" style="display:none;" playsinline></video>
    <canvas id="webcam-preview"></canvas>

    <!-- HUD Interface -->
    <div id="ui-layer">
        <div class="hud-text">
            <h1>Merry Christmas ğŸ„ AI</h1>
            <div id="status">ç­‰å¾…æ‘„åƒå¤´...</div>
            <div style="font-size: 0.8rem; margin-top:10px; opacity: 0.8;">
                âœŠ æ¡æ‹³ï¼šèšåˆåœ£è¯æ ‘ <br>
                ğŸ– å¼ å¼€ï¼šæ˜Ÿæ•£æ¨¡å¼ <br>
                ğŸ‘‹ ç§»åŠ¨ï¼šæ—‹è½¬è§†è§’ <br>
                ğŸ‘Œ æåˆï¼šæŸ¥çœ‹ç…§ç‰‡
            </div>
        </div>
        
        <div id="controls">
            <div class="hud-text" style="font-size: 0.9rem; margin-bottom: 10px;">æŒ‚è½½è®°å¿†ç…§ç‰‡</div>
            <input type="file" id="photo-upload" multiple accept="image/*">
            <p style="font-size: 0.7rem; color: #aaa;">æ”¯æŒå¤šé€‰ï¼Œå»ºè®®ä¸Šä¼ æ­£æ–¹å½¢å›¾ç‰‡</p>
        </div>
    </div>

    <!-- Libraries -->
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Post Processing -->
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <!-- GSAP for Animations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- é…ç½®ä¸çŠ¶æ€ç®¡ç† ---
        const CONFIG = {
            particleCount: 400, // è£…é¥°çƒæ•°é‡
            photoCount: 20,     // ç…§ç‰‡ä½æ•°é‡
            treeHeight: 30,
            treeRadius: 12,
            colors: [0x2F4F4F, 0xB8860B, 0x8B0000, 0xFFFFFF], // ç»¿, é‡‘, çº¢, ç™½
        };

        const STATE = {
            mode: 'TREE', // TREE, SCATTER, ZOOM
            gesture: 'NONE',
            handX: 0.5,
            handY: 0.5,
            targetRotationY: 0,
            zoomIndex: -1
        };

        // Three.js å…¨å±€å˜é‡
        let scene, camera, renderer, composer;
        let particles = [], photoPlanes = [];
        let group; // åŒ…å«æ‰€æœ‰å…ƒç´ çš„ç»„
        const textureLoader = new THREE.TextureLoader();

        // å ä½å›¾ç”Ÿæˆ
        const createPlaceholderTexture = (text, color) => {
            const cvs = document.createElement('canvas');
            cvs.width = 256; cvs.height = 256;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0,0,256,256);
            ctx.fillStyle = '#fff';
            ctx.font = '40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, 128, 128);
            return new THREE.CanvasTexture(cvs);
        };

        // --- 1. åˆå§‹åŒ– Three.js åœºæ™¯ ---
        function initThree() {
            const container = document.getElementById('canvas-container');
            
            // åœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050a05, 0.02);

            // ç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 10, 40);
            camera.lookAt(0, 10, 0);

            // æ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            container.appendChild(renderer.domElement);

            // è¾‰å…‰åæœŸå¤„ç† (Cinematic Glow)
            const renderScene = new THREE.RenderPass(scene, camera);
            const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.2;
            bloomPass.strength = 1.2; // å¼ºåº¦
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffd700, 1.5, 100);
            pointLight.position.set(10, 20, 10);
            scene.add(pointLight);

            // æ ¸å¿ƒç»„
            group = new THREE.Group();
            scene.add(group);

            createObjects();
            
            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
            
            // å¯åŠ¨åŠ¨ç”»å¾ªç¯
            animate();
        }

        // --- 2. åˆ›å»ºç²’å­ä¸ç…§ç‰‡å¯¹è±¡ ---
        function createObjects() {
            // å‡ ä½•ä½“å¤ç”¨
            const geomSphere = new THREE.SphereGeometry(0.4, 16, 16);
            const geomBox = new THREE.BoxGeometry(0.6, 0.6, 0.6);

            // æè´¨å¤ç”¨
            const matGold = new THREE.MeshStandardMaterial({ color: 0xD4AF37, metalness: 0.8, roughness: 0.2 });
            const matRed = new THREE.MeshStandardMaterial({ color: 0x8B0000, metalness: 0.3, roughness: 0.4, emissive: 0x330000 });
            const matGreen = new THREE.MeshStandardMaterial({ color: 0x2F4F4F, roughness: 0.9 });

            // A. åˆ›å»ºè£…é¥°ç²’å­
            for (let i = 0; i < CONFIG.particleCount; i++) {
                const isSphere = Math.random() > 0.3;
                const mesh = new THREE.Mesh(isSphere ? geomSphere : geomBox, 
                                            Math.random() > 0.6 ? matGold : (Math.random() > 0.5 ? matRed : matGreen));
                
                // è®¡ç®—åœ£è¯æ ‘å½¢æ€åæ ‡ (åœ†é”¥èºæ—‹)
                const p = i / CONFIG.particleCount;
                const angle = i * 137.5 * (Math.PI / 180); // é»„é‡‘è§’
                const y = p * CONFIG.treeHeight;
                const r = (1 - p) * CONFIG.treeRadius;
                
                const treePos = {
                    x: Math.cos(angle) * r,
                    y: y - CONFIG.treeHeight/2 + 5,
                    z: Math.sin(angle) * r
                };

                // è®¡ç®—æ•£å¼€å½¢æ€åæ ‡ (éšæœº)
                const scatterPos = {
                    x: (Math.random() - 0.5) * 60,
                    y: (Math.random() - 0.5) * 40 + 10,
                    z: (Math.random() - 0.5) * 40
                };

                // åˆå§‹ä½ç½®è®¾ä¸ºæ ‘
                mesh.position.set(treePos.x, treePos.y, treePos.z);
                
                // å­˜å‚¨å…ƒæ•°æ®
                mesh.userData = { treePos, scatterPos, type: 'deco' };
                particles.push(mesh);
                group.add(mesh);
            }

            // B. åˆ›å»ºç…§ç‰‡å¹³é¢
            const planeGeom = new THREE.PlaneGeometry(3, 3);
            for (let i = 0; i < CONFIG.photoCount; i++) {
                const mat = new THREE.MeshBasicMaterial({ 
                    map: createPlaceholderTexture('Photo', '#444'),
                    side: THREE.DoubleSide
                });
                const mesh = new THREE.Mesh(planeGeom, mat);

                // æ ‘å½¢æ€ï¼šå›´ç»•è¡¨é¢åˆ†å¸ƒ
                const p = i / CONFIG.photoCount;
                const angle = i * 45; 
                const y = p * (CONFIG.treeHeight - 5);
                const r = (1 - p) * (CONFIG.treeRadius + 1); // ç¨å¾®æµ®å‡ºè¡¨é¢
                
                const treePos = {
                    x: Math.cos(angle) * r,
                    y: y - CONFIG.treeHeight/2 + 5,
                    z: Math.sin(angle) * r
                };
                
                // æ•£å¼€å½¢æ€
                const scatterPos = {
                    x: (Math.random() - 0.5) * 50,
                    y: (Math.random() - 0.5) * 30 + 10,
                    z: (Math.random() - 0.5) * 30 + 10 // ç¨å¾®é å‰
                };

                mesh.position.set(treePos.x, treePos.y, treePos.z);
                mesh.lookAt(0, treePos.y, 0); // é¢å‘ä¸­å¿ƒ

                mesh.userData = { 
                    treePos, 
                    scatterPos, 
                    type: 'photo',
                    id: i,
                    originalScale: 1
                };
                
                photoPlanes.push(mesh);
                group.add(mesh);
            }
        }

        // --- 3. åŠ¨ç”»ä¸è¿‡æ¸¡é€»è¾‘ (GSAP) ---
        function transitionTo(newState) {
            if (STATE.mode === newState && newState !== 'ZOOM') return;
            
            console.log(`Transitioning to ${newState}`);
            STATE.mode = newState;
            const statusEl = document.getElementById('status');

            if (newState === 'TREE') {
                statusEl.innerText = "çŠ¶æ€: ğŸ„ åœ£è¯æ ‘ (æ¡æ‹³)";
                statusEl.className = "";
                
                // è¿˜åŸæ‰€æœ‰ç²’å­
                particles.forEach(p => {
                    gsap.to(p.position, { duration: 1.5, x: p.userData.treePos.x, y: p.userData.treePos.y, z: p.userData.treePos.z, ease: "elastic.out(1, 0.5)" });
                    gsap.to(p.rotation, { duration: 1.5, x: 0, y: 0, z: 0 });
                });
                // è¿˜åŸæ‰€æœ‰ç…§ç‰‡
                photoPlanes.forEach(p => {
                    gsap.to(p.position, { duration: 1.5, x: p.userData.treePos.x, y: p.userData.treePos.y, z: p.userData.treePos.z, ease: "power2.out" });
                    gsap.to(p.scale, { duration: 1, x: 1, y: 1, z: 1 });
                    // è®©ç…§ç‰‡é¢å‘ä¸­å¿ƒ
                    const lookAtVec = new THREE.Vector3(0, p.userData.treePos.y, 0);
                    // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªä¸´æ—¶çš„Tweenæ¥æ›´æ–°lookAtå¯èƒ½æ¯”è¾ƒå¤æ‚ï¼Œç®€å•å¤„ç†ï¼šåœ¨updateä¸­å¤„ç†æˆ–ç›´æ¥è®¾ç½®ç»“æŸæ—‹è½¬
                    // ä¸ºç®€åŒ–ï¼Œç›´æ¥é‡ç½®åˆ°é¢å‘ä¸­å¿ƒï¼ˆéœ€è¦è®¡ç®—å››å…ƒæ•°ï¼‰ï¼Œè¿™é‡Œç®€åŒ–ä¸ºç›´æ¥é£å›
                    p.lookAt(0, p.userData.treePos.y, 0); 
                });
                
                gsap.to(group.rotation, { duration: 1, y: 0 }); // é‡ç½®æ•´ä½“æ—‹è½¬

            } else if (newState === 'SCATTER') {
                statusEl.innerText = "çŠ¶æ€: âœ¨ æ˜Ÿæ•£ (å¼ å¼€æ‰‹æŒ)";
                statusEl.className = "status-active";

                particles.forEach(p => {
                    gsap.to(p.position, { duration: 2, x: p.userData.scatterPos.x, y: p.userData.scatterPos.y, z: p.userData.scatterPos.z, ease: "power2.inOut" });
                    gsap.to(p.rotation, { duration: 3, x: Math.random()*Math.PI, y: Math.random()*Math.PI, ease: "none", repeat: -1, yoyo: true });
                });
                
                photoPlanes.forEach(p => {
                    gsap.to(p.position, { duration: 2, x: p.userData.scatterPos.x, y: p.userData.scatterPos.y, z: p.userData.scatterPos.z, ease: "power2.inOut" });
                    gsap.to(p.scale, { duration: 1, x: 1, y: 1, z: 1 });
                    gsap.to(p.rotation, { duration: 2, x: 0, y: 0, z: 0 }); // é¢å‘å‰æ–¹
                });
            } else if (newState === 'ZOOM') {
                 statusEl.innerText = "çŠ¶æ€: ğŸ–¼ï¸ ç…§ç‰‡èšç„¦ (æåˆ)";
                 // æ‰¾åˆ°ç¦»ç›¸æœºæœ€è¿‘çš„æˆ–éšæœºä¸€å¼ ç…§ç‰‡æ”¾å¤§ï¼Œå…¶ä»–çš„æ¨è¿œ
                 const targetIndex = Math.floor(Math.random() * photoPlanes.length);
                 const targetPhoto = photoPlanes[targetIndex];
                 
                 // ç›¸æœºä½ç½®å›ºå®šï¼Œæˆ‘ä»¬å°†ç…§ç‰‡ç§»åˆ°ç›¸æœºé¢å‰
                 // ä¸–ç•Œåæ ‡è½¬ä¸ºç›¸æœºå‰æ–¹çš„åæ ‡
                 const inFrontOfCamera = new THREE.Vector3(0, 0, -10).applyMatrix4(camera.matrixWorld);

                 photoPlanes.forEach((p, idx) => {
                     if(idx === targetIndex) {
                         gsap.to(p.position, { 
                             duration: 1, 
                             x: inFrontOfCamera.x, 
                             y: inFrontOfCamera.y, 
                             z: inFrontOfCamera.z, 
                             ease: "power3.out" 
                        });
                         gsap.to(p.rotation, { duration: 1, x: camera.rotation.x, y: camera.rotation.y, z: camera.rotation.z });
                         gsap.to(p.scale, { duration: 1, x: 3, y: 3, z: 3 });
                     } else {
                         // å…¶ä»–ç…§ç‰‡ç¨å¾®é€€åå˜æš—ï¼ˆè¿™é‡Œåªåšä½ç½®ç§»åŠ¨ï¼‰
                         gsap.to(p.scale, { duration: 1, x: 0.5, y: 0.5 });
                     }
                 });
            }
        }

        // --- 4. MediaPipe Hands é›†æˆ ---
        function initMediaPipe() {
            const videoElement = document.getElementById('input-video');
            const previewCanvas = document.getElementById('webcam-preview');
            const previewCtx = previewCanvas.getContext('2d');
            
            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });

            hands.onResults((results) => {
                // ç»˜åˆ¶é¢„è§ˆ
                previewCtx.save();
                previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
                previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    drawConnectors(previewCtx, results.multiHandLandmarks[0], HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    
                    // åˆ†ææ‰‹åŠ¿
                    analyzeGesture(results.multiHandLandmarks[0]);
                } else {
                    // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹
                    // å¯ä»¥é€‰æ‹©è‡ªåŠ¨æ—‹è½¬æˆ–ä¿æŒçŠ¶æ€
                }
                previewCtx.restore();
            });

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            
            cameraUtils.start()
                .then(() => {
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('status').innerText = "ç³»ç»Ÿå°±ç»ª - è¯·å±•ç¤ºæ‰‹åŠ¿";
                })
                .catch(err => {
                    document.getElementById('loading').innerText = "æ‘„åƒå¤´è®¿é—®å¤±è´¥";
                    console.error(err);
                });
        }

        // æ‰‹åŠ¿åˆ†æé€»è¾‘
        function analyzeGesture(landmarks) {
            // åæ ‡ï¼šlandmarks[i].x, .y, .z (Normalized 0-1)
            
            // 1. è®¡ç®—æ‰‹æŒ‡çŠ¶æ€ (å¼€/åˆ)
            // ç®€å•çš„åˆ¤æ–­ï¼šæŒ‡å°–(Tip)åˆ°æ‰‹è…•(0)çš„è·ç¦» vs æŒ‡å…³èŠ‚(PIP)åˆ°æ‰‹è…•çš„è·ç¦»
            // Index: 8, Middle: 12, Ring: 16, Pinky: 20. Wrist: 0.
            
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18];
            
            let extendedFingers = 0;
            for(let i=0; i<4; i++) {
                // ç®€å•æ¬§å‡ é‡Œå¾—è·ç¦»å¹³æ–¹æ¯”è¾ƒ
                const dTip = distSq(landmarks[tips[i]], wrist);
                const dPip = distSq(landmarks[pips[i]], wrist);
                if (dTip > dPip) extendedFingers++;
            }

            // æ‹‡æŒ‡åˆ¤æ–­ (æœ‰ç‚¹ç‰¹æ®Šï¼Œåˆ¤æ–­xåç§»)
            const thumbTip = landmarks[4];
            const thumbIp = landmarks[3];
            // ç®€åŒ–ï¼šå¦‚æœæ‹‡æŒ‡å°–è¿œç¦»å°æŒ‡æ ¹éƒ¨
            if (distSq(thumbTip, landmarks[17]) > 0.05) extendedFingers++;

            // 2. æåˆåˆ¤æ–­ (æ‹‡æŒ‡ä¸é£ŸæŒ‡è·ç¦»)
            const pinchDist = Math.sqrt(distSq(landmarks[4], landmarks[8]));
            const isPinch = pinchDist < 0.05;

            // 3. çŠ¶æ€æœºè§¦å‘
            let newGesture = STATE.gesture;

            if (isPinch) {
                newGesture = 'PINCH';
                if (STATE.mode === 'SCATTER') transitionTo('ZOOM');
            } else if (extendedFingers <= 1) {
                newGesture = 'FIST';
                transitionTo('TREE');
            } else if (extendedFingers >= 4) {
                newGesture = 'OPEN';
                if (STATE.mode !== 'ZOOM') transitionTo('SCATTER'); // ZOOMæ€éœ€è¦ç­‰å¾…æˆ–ç‰¹å®šåŠ¨ä½œé€€å‡º? è¿™é‡Œç®€åŒ–ä¸ºåªè¦å¼ å¼€å°±æ•£å¼€
                else if (STATE.mode === 'ZOOM') transitionTo('SCATTER'); // é€€å‡ºæ”¾å¤§
            }

            STATE.gesture = newGesture;

            // 4. æ›´æ–°äº¤äº’æ•°æ® (ç”¨äºæ—‹è½¬)
            // ç”¨æ‰‹æŒä¸­å¿ƒ (9å·ç‚¹ roughly) çš„Xåæ ‡æ§åˆ¶æ—‹è½¬
            // æ˜ å°„ 0-1 åˆ° -PI åˆ° PI
            const handX = landmarks[9].x; 
            // å¹³æ»‘å¤„ç†
            STATE.handX += (handX - STATE.handX) * 0.1; 
            
            if (STATE.mode === 'SCATTER' && !isPinch) {
                // è¿™ç§æ˜ å°„ä¼šè®©æ‰‹ç§»åŠ¨æ—¶åœºæ™¯æ—‹è½¬
                const rot = (STATE.handX - 0.5) * 4; // çµæ•åº¦
                // åªæœ‰æ‰‹åœ¨åŠ¨çš„æ—¶å€™æ‰è½¬ï¼Ÿæˆ–è€…ç»å¯¹æ˜ å°„ï¼Ÿ
                // ç»å¯¹æ˜ å°„æ¯”è¾ƒç›´è§‚ï¼šæ‰‹åœ¨å·¦è¾¹ï¼Œåœºæ™¯å¾€å·¦è½¬
                gsap.to(group.rotation, { y: rot, duration: 0.5 });
            }
        }

        function distSq(p1, p2) {
            return (p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2;
        }

        // --- 5. å·¥å…·å‡½æ•°ä¸äº‹ä»¶ ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // è‡ªåŠ¨æ—‹è½¬ (ä»…åœ¨Treeæ¨¡å¼ä¸”æ²¡æœ‰æ‰‹åŠ¿å¹²æ‰°æ—¶å¾®è½¬)
            if (STATE.mode === 'TREE') {
                group.rotation.y += 0.002;
            }

            // ç²’å­è‡ªèº«çš„æµ®åŠ¨åŠ¨ç”» (åœ¨Scatteræ¨¡å¼ä¸‹)
            if (STATE.mode === 'SCATTER') {
                const time = Date.now() * 0.001;
                particles.forEach((p, i) => {
                    p.position.y += Math.sin(time + i) * 0.02;
                });
            }

            composer.render();
        }

        // ç…§ç‰‡ä¸Šä¼ å¤„ç†
        document.getElementById('photo-upload').addEventListener('change', (e) => {
            const files = e.target.files;
            if (!files.length) return;

            Array.from(files).forEach((file, i) => {
                if (i >= photoPlanes.length) return;
                
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const img = new Image();
                    img.src = evt.target.result;
                    img.onload = () => {
                        const tex = new THREE.Texture(img);
                        tex.needsUpdate = true;
                        // æ›¿æ¢æè´¨
                        photoPlanes[i].material.map = tex;
                        photoPlanes[i].material.needsUpdate = true;
                    }
                };
                reader.readAsDataURL(file);
            });
            alert(`å·²åŠ è½½ ${Math.min(files.length, photoPlanes.length)} å¼ ç…§ç‰‡ï¼åšå‡º "å¼ å¼€æ‰‹æŒ" çš„æ‰‹åŠ¿æ¥çœ‹çœ‹å§ï¼`);
        });

        // --- å¯åŠ¨ ---
        initThree();
        initMediaPipe();

    </script>
</body>
</html>
